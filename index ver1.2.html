<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Magic Christmas - Carousel (Flip + Music Click-to-Start)</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body { margin:0; overflow:hidden; background:#000; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #canvas-container { width:100%; height:100vh; display:block; }

    /* auto start */
    #ui-layer { display:none; }

    #camera-preview{
      position:absolute; top:15px; right:15px;
      width:120px; height:90px;
      border:2px solid rgba(255,0,0,0.5);
      transform: scaleX(-1);
      opacity:0.65;
      border-radius:10px;
      z-index:100;
    }

    #error-log{
      position:absolute; left:12px; top:12px;
      z-index:999;
      color:#ff6b6b;
      background:rgba(0,0,0,0.65);
      border:1px solid rgba(255,255,255,0.15);
      padding:10px 12px;
      border-radius:10px;
      font-size:12px;
      max-width:520px;
      display:none;
      white-space:pre-wrap;
      line-height:1.3;
    }

    #hint{
      position:absolute; left:12px; bottom:12px;
      z-index:999;
      color:rgba(255,255,255,0.85);
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.12);
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      max-width:720px;
      user-select:none;
    }

    /* Click-to-start overlay for audio permission */
    #start-audio{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.78);
      color:white;
      z-index:2000;
      cursor:pointer;
      font-size:18px;
      font-weight:700;
      letter-spacing:0.2px;
      text-align:center;
      padding:24px;
    }
    #start-audio small{
      display:block;
      margin-top:10px;
      opacity:0.8;
      font-weight:500;
      font-size:13px;
      line-height:1.3;
    }
  </style>
</head>

<body>
  <div id="error-log"></div>

  <div id="hint"> 
    âœŠ = cÃ¢y thÃ´ng â€¢ âœ‹ = má»Ÿ cÃ¢y thÃ´ng â€¢ ðŸ‘Œ = xem hÃ¬nh
  </div>

  <div id="canvas-container"></div>

  <!-- Click to start music (required by browser autoplay policy) -->
  <div id="start-audio">
    Click anywhere to start ðŸŽµ
    <small>
      (Browsers block autoplay audio until you click / tap once.)
    </small>
  </div>

  <video class="input_video" style="display:none"></video>
  <canvas id="camera-preview"></canvas>

  <script>
    // ============================================================
    // 0) Helpers
    // ============================================================
    const logEl = document.getElementById("error-log");
    function log(msg){
      console.log(msg);
      logEl.style.display = "block";
      logEl.textContent += msg + "\n";
    }

    function makePlaceholderTexture(label, bg = "#1b1b1b", fg = "#ffd700") {
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const g = c.getContext("2d");
      g.fillStyle = bg; g.fillRect(0,0,512,512);
      g.strokeStyle = "rgba(255,255,255,0.15)";
      g.lineWidth = 8;
      g.strokeRect(20,20,472,472);

      g.fillStyle = fg;
      g.font = "bold 48px system-ui";
      g.textAlign = "center";
      g.fillText(label, 256, 260);

      const t = new THREE.CanvasTexture(c);
      t.needsUpdate = true;
      return t;
    }

    // ============================================================
    // 1) Music
    // ============================================================
    const MUSIC_URL = "./audio.mp3"; // ensure this file exists
    const bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true;
    bgMusic.volume = 1.0;

    // ============================================================
    // 2) Textures
    // ============================================================
    function createCustomTexture(type) {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      const cx = 64, cy = 64;

      if (type === 'tree_green') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 52);
        grd.addColorStop(0, 'rgba(120,255,120,1)');
        grd.addColorStop(0.35, 'rgba(0,255,120,0.95)');
        grd.addColorStop(0.75, 'rgba(0,180,70,0.7)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
      }

      if (type === 'led_warm') {
        const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 58);
        grd.addColorStop(0, '#FFFFFF');
        grd.addColorStop(0.20, '#FFFDE7');
        grd.addColorStop(0.55, '#FFD54F');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);
      }

      if (type === 'gift_red') {
        ctx.fillStyle = '#D32F2F'; ctx.fillRect(20, 20, 88, 88);
        ctx.fillStyle = '#FFD700'; ctx.fillRect(54, 20, 20, 88); ctx.fillRect(20, 54, 88, 20);
        ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2; ctx.strokeRect(20, 20, 88, 88);
      }

      const t = new THREE.CanvasTexture(canvas);
      t.needsUpdate = true;
      return t;
    }

    function createRadialGlowTexture() {
      const c = document.createElement('canvas');
      c.width = 256; c.height = 256;
      const g = c.getContext('2d');
      const cx = 128, cy = 128;

      const grd = g.createRadialGradient(cx, cy, 0, cx, cy, 120);
      grd.addColorStop(0.00, 'rgba(255, 255, 255, 1)');
      grd.addColorStop(0.18, 'rgba(255, 240, 180, 0.9)');
      grd.addColorStop(0.45, 'rgba(255, 210, 90, 0.45)');
      grd.addColorStop(1.00, 'rgba(0, 0, 0, 0)');

      g.fillStyle = grd;
      g.fillRect(0, 0, 256, 256);

      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      return tex;
    }

    const textures = {
      green: createCustomTexture('tree_green'),
      led: createCustomTexture('led_warm'),
      gift: createCustomTexture('gift_red'),
      glow: createRadialGlowTexture()
    };

    // ============================================================
    // 3) Photos (safe load + fallback)
    // ============================================================
    const loader = new THREE.TextureLoader();

    const photoFiles = [
      "./unknown.jpg",
      "./unknown-2.jpg",
      "./unknown-3.jpg",
      "./unknown-4.jpg",
      "./unknown-5.jpg",
      "./unknown-6.jpg",
      "./unknown-7.jpg",
      "./unknown-8.jpg",
      "./unknown-9.jpg",
      "./unknown-10.jpg",
      "./unknown-11.jpg",
      "./unknown-12.jpg",
      "./unknown-13.jpg",
      "./unknown-14.jpg",
    ];

    // Map backs 1:1 by index (photoFiles[i] -> backFiles[i])
    const backFiles = [
      "./back-1.png",
      "./back-2.png",
      "./back-3.png",
      "./back-4.png",
      "./back-5.png",
      "./back-6.png",
      "./back-7.png",
      "./back-8.png",
      "./back-9.png",
      "./back-10.png",
      "./back-11.png",
      "./back-12.png",
      "./back-13.png",
      "./back-14.png",
    ];

    // FRONT placeholders
    const photoTextures = photoFiles.map((_, i) => makePlaceholderTexture(`Photo ${i+1}`));

    // BACK placeholders
    const backTextures = backFiles.map((_, i) => makePlaceholderTexture(`BACK ${i+1}`, "#101018", "#7ee7ff"));

    // load FRONT
    photoFiles.forEach((url, i) => {
      loader.load(
        url,
        (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace ? THREE.SRGBColorSpace : undefined;
          photoTextures[i] = tex;
        },
        undefined,
        () => { log(`Missing image: ${url} (using placeholder)`); }
      );
    });

    // load BACK
    backFiles.forEach((url, i) => {
      loader.load(
        url,
        (tex) => {
          tex.colorSpace = THREE.SRGBColorSpace ? THREE.SRGBColorSpace : undefined;
          backTextures[i] = tex;
        },
        undefined,
        () => { log(`Missing back image: ${url} (using placeholder)`); }
      );
    });

    // ============================================================
    // 4) Config
    // ============================================================
    const CONFIG = {
      greenCount: 900,
      giftCount: 80,
      stripCount: 420,

      explodeRadius: 65,
      treeHeight: 70,
      treeBaseRadius: 35,

      // carousel config
      photoSize: 10,          // bigger photos
      photoOrbitRadius: 55,   // more spacing so they don't overlap
      photoYBob: 1.8,
      photoRotateEase: 0.04,
    };

    // ============================================================
    // 5) Scene globals
    // ============================================================
    let scene, camera, renderer;
    let groupGreen, groupGift, groupStrip;
    let titleMesh, starMesh;
    let ambientLight, starLight;

    // states: TREE, EXPLODE
    let state = "TREE";
    let selectedIndex = 0;

    // input
    let handX = 0.5;

    // carousel rotation
    let carouselAngle = 0;
    let carouselAngleTarget = 0;

    // photo cards (2-sided)
    let photoCards = []; // { group, front, back, flipped, flipY, flipTargetY }

    // pinch edge detection
    let wasPinching = false;

    // flip speed
    const FLIP_LERP = 0.16;

    // ============================================================
    // 6) Particle systems
    // ============================================================
    function createParticleSystem(type, count, size) {
      const pPositions = [];
      const pExplodeTargets = [];
      const pTreeTargets = [];
      const sizes = [];
      const phases = [];

      for (let i = 0; i < count; i++) {
        const h = Math.random() * CONFIG.treeHeight;
        const y = h - CONFIG.treeHeight / 2;

        let radiusRatio;
        if (type === 'green') radiusRatio = Math.sqrt(Math.random());
        else radiusRatio = 0.90 + Math.random() * 0.10;

        const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
        const r = maxR * radiusRatio;
        const theta = Math.random() * Math.PI * 2;

        pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

        // explode target
        const u = Math.random();
        const v = Math.random();
        const phi = Math.acos(2 * v - 1);
        const lam = 2 * Math.PI * u;
        const radMult = (type === 'gift') ? 1.2 : 1.0;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;

        pExplodeTargets.push(
          rad * Math.sin(phi) * Math.cos(lam),
          rad * Math.sin(phi) * Math.sin(lam),
          rad * Math.cos(phi)
        );

        pPositions.push(pTreeTargets[i*3], pTreeTargets[i*3+1], pTreeTargets[i*3+2]);
        sizes.push(size);
        phases.push(Math.random() * Math.PI * 2);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const baseColor = new THREE.Color(type === "green" ? 0x00FF66 : 0xFFFFFF);
      const colors = new Float32Array(count * 3);
      for (let i=0;i<count;i++){
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
      }
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      geo.userData = { tree: pTreeTargets, explode: pExplodeTargets, phases, baseColor, baseSize: size };

      const mat = new THREE.PointsMaterial({
        size,
        map: textures[type],
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        blending: (type === "gift") ? THREE.NormalBlending : THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }

    // ---------- STRIP ----------
    function stripPosAt(t, extraRot = 0) {
      const y = -CONFIG.treeHeight/2 + t * CONFIG.treeHeight;
      const maxR = (1 - t) * CONFIG.treeBaseRadius;
      const r = maxR * 0.98;
      const wraps = 9.5;
      const theta = t * wraps * Math.PI * 2 + extraRot;
      return { x: Math.cos(theta) * r, y, z: Math.sin(theta) * r, r, t };
    }

    function createStripSystem(count, size) {
      const pPositions = [];
      const pExplodeTargets = [];
      const baseT = [];
      const phases = [];

      for (let i=0;i<count;i++){
        const t = i / count;
        baseT.push(t);

        const p = stripPosAt(t);
        pPositions.push(p.x, p.y, p.z);

        const u = Math.random();
        const v = Math.random();
        const phi = Math.acos(2 * v - 1);
        const lam = 2 * Math.PI * u;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random());
        pExplodeTargets.push(
          rad * Math.sin(phi) * Math.cos(lam),
          rad * Math.sin(phi) * Math.sin(lam),
          rad * Math.cos(phi)
        );

        phases.push(Math.random() * Math.PI * 2);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(new Array(count).fill(size), 1));

      const baseColor = new THREE.Color(0xFFD54F);
      const colors = new Float32Array(count*3);
      for (let i=0;i<count;i++){
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
      }
      geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      geo.userData = { explode: pExplodeTargets, baseT, phases, baseColor, baseSize: size };

      const mat = new THREE.PointsMaterial({
        size,
        map: textures.led,
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });

      const pts = new THREE.Points(geo, mat);
      scene.add(pts);
      return pts;
    }

    function updateStrip(targetState, speed, handRotY, time) {
      const geo = groupStrip.geometry;
      const pos = geo.attributes.position.array;
      const col = geo.attributes.color.array;
      const siz = geo.attributes.size.array;

      const baseT = geo.userData.baseT;
      const phases = geo.userData.phases;
      const baseColor = geo.userData.baseColor;
      const baseSize = geo.userData.baseSize;

      const n = baseT.length;

      if (targetState === "TREE") {
        const head = (time * 0.22) % 1;
        const extraRot = time * 0.55;

        for (let i=0;i<n;i++){
          let t = (baseT[i] + time * 0.10) % 1;
          const p = stripPosAt(t, extraRot);

          pos[i*3]     += (p.x - pos[i*3]) * speed;
          pos[i*3 + 1] += (p.y - pos[i*3+1]) * speed;
          pos[i*3 + 2] += (p.z - pos[i*3+2]) * speed;

          const d = Math.min(Math.abs(t - head), 1 - Math.abs(t - head));
          const headGlow = Math.exp(-(d*d) / 0.0025);
          const tw = 0.70 + 0.30 * Math.max(0, Math.sin(time*10 + phases[i]));
          const b = 0.30 + 1.60 * headGlow + 0.35 * tw;

          col[i*3] = baseColor.r * b;
          col[i*3+1] = baseColor.g * b;
          col[i*3+2] = baseColor.b * b;

          siz[i] = baseSize * (0.95 + 0.9 * headGlow);
        }

        geo.attributes.position.needsUpdate = true;
        geo.attributes.color.needsUpdate = true;
        geo.attributes.size.needsUpdate = true;

        groupStrip.rotation.y += 0.003;
        return;
      }

      const targets = geo.userData.explode;
      for (let k=0;k<pos.length;k++){
        pos[k] += (targets[k] - pos[k]) * speed;
      }
      groupStrip.rotation.y += (handRotY - groupStrip.rotation.y) * 0.1;
      geo.attributes.position.needsUpdate = true;
    }

    // --------- STAR ----------
    function create3DStarMesh() {
      const spikes = 5;
      const outerR = 4.4;
      const innerR = 2.2;

      const shape = new THREE.Shape();
      const step = Math.PI / spikes;
      shape.moveTo(0, outerR);
      for (let i=0;i<spikes*2;i++){
        const r = (i%2===0) ? outerR : innerR;
        const a = (Math.PI/2) + i*step;
        shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      shape.closePath();

      const geo = new THREE.ExtrudeGeometry(shape, {
        depth: 0.9,
        bevelEnabled: true,
        bevelThickness: 0.22,
        bevelSize: 0.22,
        bevelSegments: 2,
        curveSegments: 24
      });
      geo.center();

      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xFFD166,
        metalness: 1.0,
        roughness: 0.18,
        clearcoat: 1.0,
        clearcoatRoughness: 0.12,
        emissive: 0xFFB703,
        emissiveIntensity: 0.18
      });

      const star = new THREE.Mesh(geo, mat);

      const glowMat = new THREE.SpriteMaterial({
        map: textures.glow,
        color: 0xFFE08A,
        transparent: true,
        opacity: 0.55,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Sprite(glowMat);
      glow.scale.set(22, 22, 1);
      glow.position.set(0, 0, -0.9);
      star.add(glow);

      return star;
    }

    // --------- Title ----------
    function createTitle() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024; canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.font = 'bold italic 90px "Times New Roman"';
      ctx.fillStyle = '#FFD700';
      ctx.textAlign = 'center';
      ctx.shadowColor = "#FF0000";
      ctx.shadowBlur = 40;
      ctx.fillText("MERRY CHRISTMAS", 512, 130);

      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
      mesh.position.set(0, 50, 0);
      scene.add(mesh);
      return mesh;
    }

    // ============================================================
    // 7) Photos: 2-sided cards + pinch flips + auto reset others
    // ============================================================
    function createPhotosAll() {
      const geo = new THREE.PlaneGeometry(CONFIG.photoSize, CONFIG.photoSize);

      for (let i=0;i<photoTextures.length;i++){
        const group = new THREE.Group();

        const frontMat = new THREE.MeshBasicMaterial({
          map: photoTextures[i],
          side: THREE.FrontSide,
          transparent: true,
          opacity: 1.0,
          depthWrite: false
        });
        const front = new THREE.Mesh(geo, frontMat);
        front.position.z = 0.01;

        const backMat = new THREE.MeshBasicMaterial({
          map: backTextures[i],
          side: THREE.FrontSide,
          transparent: true,
          opacity: 1.0,
          depthWrite: false
        });
        const back = new THREE.Mesh(geo, backMat);
        back.rotation.y = Math.PI;
        back.position.z = -0.01;

        group.add(front);
        group.add(back);

        group.visible = false;
        group.scale.set(0,0,0);
        scene.add(group);

        photoCards.push({
          group, front, back,
          flipped: false,
          flipY: 0,
          flipTargetY: 0
        });
      }
    }

    function updatePhotoMaterials() {
      for (let i=0;i<photoCards.length;i++){
        const c = photoCards[i];
        if (c.front.material.map !== photoTextures[i]) {
          c.front.material.map = photoTextures[i];
          c.front.material.needsUpdate = true;
        }
        if (c.back.material.map !== backTextures[i]) {
          c.back.material.map = backTextures[i];
          c.back.material.needsUpdate = true;
        }
      }
    }

    function setCardOpacity(card, a){
      card.front.material.opacity = a;
      card.back.material.opacity = a;
    }

    function updateCarouselAngle() {
      const x = (handX - 0.5) * 2.0;     // -1..1
      carouselAngleTarget += x * 0.005;   // spin speed
      carouselAngle += (carouselAngleTarget - carouselAngle) * CONFIG.photoRotateEase;
    }

    // âœ… pinch flip selected; also reset all other cards back to FRONT
    function toggleFlipSelected() {
      for (let i = 0; i < photoCards.length; i++) {
        if (i === selectedIndex) continue;
        const c = photoCards[i];
        c.flipped = false;
        c.flipTargetY = 0;
      }

      const card = photoCards[selectedIndex];
      if (!card) return;

      card.flipped = !card.flipped;
      card.flipTargetY = card.flipped ? Math.PI : 0;
    }

    function updateFlipAnimations() {
      for (const c of photoCards) {
        c.flipY += (c.flipTargetY - c.flipY) * FLIP_LERP;
      }
    }

    function updatePhotos(time) {
      const n = photoCards.length;
      if (n === 0) return;

      if (state === "EXPLODE") {
        updateCarouselAngle();
        updateFlipAnimations();

        const step = (Math.PI * 2) / n;
        let bestIdx = 0;
        let maxZ = -99999;

        for (let i=0;i<n;i++){
          const card = photoCards[i];
          const group = card.group;
          group.visible = true;

          const angle = carouselAngle + i * step;

          const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
          const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
          const y = Math.sin(time * 1.1 + i * 0.7) * CONFIG.photoYBob;

          group.position.lerp(new THREE.Vector3(x, y, z), 0.14);

          // face camera then flip
          group.lookAt(camera.position);
          group.rotateY(card.flipY);

          const front = THREE.MathUtils.clamp((z + CONFIG.photoOrbitRadius) / (2 * CONFIG.photoOrbitRadius), 0, 1);

          // Bigger front image
          const s = 0.8 + front * 2.8;
          group.scale.lerp(new THREE.Vector3(s, s, s), 0.14);

          setCardOpacity(card, 0.25 + front * 0.75);

          if (z > maxZ) { maxZ = z; bestIdx = i; }
        }

        selectedIndex = bestIdx;
        return;
      }

      // TREE => hide photos
      for (const card of photoCards) {
        card.group.visible = false;
        card.group.scale.lerp(new THREE.Vector3(0,0,0), 0.18);
      }
    }

    // ============================================================
    // 8) Update particle groups
    // ============================================================
    function updateParticleGroup(group, type, targetState, speed, handRotY, time) {
      const pos = group.geometry.attributes.position.array;
      const col = group.geometry.attributes.color.array;
      const siz = group.geometry.attributes.size.array;

      const phases = group.geometry.userData.phases;
      const baseColor = group.geometry.userData.baseColor;
      const baseSize = group.geometry.userData.baseSize;

      const targets = (targetState === "TREE")
        ? group.geometry.userData.tree
        : group.geometry.userData.explode;

      for (let k=0;k<pos.length;k++){
        pos[k] += (targets[k] - pos[k]) * speed;
      }
      group.geometry.attributes.position.needsUpdate = true;

      const count = pos.length / 3;

      if (targetState === "TREE") {
        group.rotation.y += 0.003;
        for (let i=0;i<count;i++){
          siz[i] = baseSize;

          let b = 1.0;
          if (type === "green") b = 0.95 + 0.05 * Math.sin(time*2 + phases[i]);

          col[i*3]   = baseColor.r * b;
          col[i*3+1] = baseColor.g * b;
          col[i*3+2] = baseColor.b * b;
        }
        group.geometry.attributes.size.needsUpdate = true;
        group.geometry.attributes.color.needsUpdate = true;
      } else {
        group.rotation.y += (handRotY - group.rotation.y) * 0.1;
      }
    }

    // ============================================================
    // 9) Init scene
    // ============================================================
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 105;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
      scene.add(ambientLight);

      starLight = new THREE.PointLight(0xfff2b0, 1.4, 260);
      starLight.position.set(0, CONFIG.treeHeight/2 + 12, 20);
      scene.add(starLight);

      groupGreen = createParticleSystem("green", CONFIG.greenCount, 2.4);
      groupGift  = createParticleSystem("gift",  CONFIG.giftCount,  3.0);
      groupStrip = createStripSystem(CONFIG.stripCount, 4.2);

      titleMesh = createTitle();
      starMesh = create3DStarMesh();
      starMesh.position.set(0, CONFIG.treeHeight/2 + 2.0, 0);
      scene.add(starMesh);

      createPhotosAll();

      animate();
    }

    // ============================================================
    // 10) Render loop
    // ============================================================
    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now() * 0.001;
      const speed = 0.08;
      const handRotY = (handX - 0.5) * 4.0;

      updatePhotoMaterials();

      updateParticleGroup(groupGreen, "green", state === "TREE" ? "TREE" : "EXPLODE", speed, handRotY, time);
      updateParticleGroup(groupGift,  "gift",  state === "TREE" ? "TREE" : "EXPLODE", speed, handRotY, time);
      updateStrip(state === "TREE" ? "TREE" : "EXPLODE", speed, handRotY, time);

      updatePhotos(time);

      const isTree = (state === "TREE");
      starMesh.visible = isTree;
      starLight.visible = isTree;
      titleMesh.visible = isTree;

      if (isTree) {
        starMesh.position.set(0, CONFIG.treeHeight/2 + 2.0, 0);
        starMesh.rotation.set(0, 0, 0);
        starLight.position.set(0, CONFIG.treeHeight/2 + 12, 20);
      }

      renderer.render(scene, camera);
    }

    // ============================================================
    // 11) Start + MediaPipe hands + Audio unlock
    // ============================================================
    function startSystem() {
      init3D();

      const video = document.getElementsByClassName('input_video')[0];
      const canvas = document.getElementById('camera-preview');
      const ctx = canvas.getContext('2d');

      const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(results => {
        ctx.clearRect(0, 0, 100, 75);
        ctx.drawImage(results.image, 0, 0, 100, 75);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const lm = results.multiHandLandmarks[0];
          handX = lm[9].x;

          const tips = [8, 12, 16, 20];
          const wrist = lm[0];
          let openDist = 0;
          tips.forEach(i => openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y));
          const avgDist = openDist / 4;

          const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
          const isPinching = pinchDist < 0.05;

          if (avgDist < 0.25) state = "TREE";
          else state = "EXPLODE";

          // Pinch start -> flip selected card
          if (isPinching && !wasPinching && state === "EXPLODE") {
            toggleFlipSelected();
          }
          wasPinching = isPinching;

        } else {
          state = "TREE";
          wasPinching = false;
        }
      });

      const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: 320,
        height: 240
      });
      cameraUtils.start();

      window.addEventListener("mousemove", (e) => {
        handX = e.clientX / window.innerWidth;
      });
    }

    window.addEventListener('resize', () => {
      if (!camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // âœ… Start everything, but unlock audio with a click
    window.addEventListener('load', () => {
      startSystem();

      const overlay = document.getElementById("start-audio");

      async function enableAudio() {
        try {
          bgMusic.muted = false;
          await bgMusic.play();
          overlay.style.display = "none";
        } catch (e) {
          console.log("Audio blocked:", e);
          // overlay stays so user can click again
        }
      }

      overlay.addEventListener("click", enableAudio, { passive: true });
      overlay.addEventListener("touchstart", enableAudio, { passive: true });
    });
  </script>
</body>
</html>
